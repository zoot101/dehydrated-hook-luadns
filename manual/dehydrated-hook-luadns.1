.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "dehydrated-hook-luadns" "1" "" "dehydrated-hook-luadns" "User Manual"
.hy
.SH NAME
.PP
\f[B]dehydrated-hook-luadns\f[R]
.SH SYNOPSIS
.PP
Dehydrated Hook Script for Luadns.com to solve the dns-01 challenge
.PP
USAGE: \f[B]dehydrated-hook-luadns [ACTION]\f[R]
.SH DESCRIPTION
.PP
Hook script for \f[B]dehydrated\f[R] to allow one to solve the dns-01
challenge using \f[B]Luadns.com\f[R].
Luadns is widely supported by other clients that can use the dns-01
challenge like certbot but not by dehydrated.
This was the motivation for the author to create the script.
.PP
The DNS-01 Challenge is quite a nice way to prove ownership of a domain
to satisfy the acme protocol in order to get trusted SSL certificates
from LetsEncrypt or other providers.
.PP
It involves the user deploying a special DNS TXT Record to prove
ownership of the domain instead of opening ports to the internet like
the http-01 challenge.
.PP
The script will also check that the record has correctly propagated
after deploying it.
It does this by initially querying the Luadns nameservers \f[B](usually
ns[1-4].luadns.net)\f[R] for the official nameservers for the domain
passed in by \f[B]dehydrated\f[R].
Then it will query each of these nameservers to ensure the record is
available on all of them before handing back control to
\f[B]dehydrated\f[R].
.PP
This script is not really intended to be used directly, but rather by
specifying as a hook script within the wider dehydrated config - see the
section on the config below.
.PP
However it\[cq]s a very good idea to test it directly before using it
with dehydrated (see below).
.SH REQUIRED DEPENDENCIES
.PP
The Following Dependencies are required to be installed:
.IP "1." 3
\f[B]curl\f[R]
.PD 0
.P
.PD
.IP "2." 3
\f[B]dig\f[R]
.PD 0
.P
.PD
.IP "3." 3
\f[B]grep\f[R]
.PD 0
.P
.PD
.IP "4." 3
\f[B]jq\f[R]
.PD 0
.P
.PD
.IP "5." 3
\f[B]awk\f[R]
.PD 0
.P
.PD
.IP "6." 3
\f[B]sed\f[R]
.SH REQUIRED DEHYDRATED CONFIG SETTINGS
.PP
To use this script, modify the \f[B]dehydrated\f[R] config, which (if
installed from the debian repos), is here:
.IP \[bu] 2
\f[B]/etc/dehydrated/config\f[R]
.PP
Or (as recommended) create a drop-in file here:
.IP \[bu] 2
\f[B]/etc/dehydrated/conf.d/config.sh\f[R]
.PP
Then add the following to the config:
.IP \[bu] 2
\f[B]CHALLENGETYPE=\[dq]dns-01\[dq]\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]HOOK=\[dq]/usr/bin/dehydrated-hook-luadns\[dq]\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]HOOK_CHAIN=\[dq]yes\[dq]\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]export lua_email=\[lq]email\[at]example.com\[rq]\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]export lua_api_key=\[lq]124\&...abc\&....uidlsj\[rq]\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]export automatic_nginx_reload=\[dq]yes\[dq]\f[R]
.PP
The \f[B]CHALLENGETYPE, HOOK\f[R], and \f[B]HOOK_CHAIN\f[R] options are
all covered in the wider dehydrated documentation and are not considered
here.
.PP
\f[B]The HOOK_CHAIN option is supported for certificates with\f[R]
\f[B]multiple alternative names.
This is useful to reduce the\f[R] \f[B]number of calls to the script.
It is recommeneded to enable\f[R] \f[B]this option within the dehydrated
config.
However the script\f[R] \f[B]will also work with
HOOK_CHAIN=\[lq]no\[rq]\f[R]
.PP
In the above config options, \f[B]lua_email\f[R] and
\f[B]lua_api_key\f[R] are the login email for your luadns.com account,
and the \f[B]lua_api_key\f[R] is an api key that you can generate via
their WebUI that has access to the DNS Zone where you want to deploy the
TXT Record.
See the section below on creating the API key.
.PP
The \f[B]automatic_nginx_reload\f[R] parameter is optional above.
It is intended to automatically reload an nginx webserver after new
certificates are issued if one is running nginx.
It can be omitted or left commented out if the user desires.
.PP
Note the script can also be passed to \f[B]dehydrated\f[R] directly by
using the \f[B]-k\f[R] or \f[B]--hook\f[R] options.
See \f[B]dehydrated(1)\f[R]
.PP
After the above lines are deployed in the wider dehydrated config, that
should allow one to solve the DNS-01 challenge via \f[B]Luadns.com\f[R]
with \f[B]dehydrated\f[R]!
.SH TESTING DIRECTLY
.PP
The script can be tested directly by following the procedure below.
It is recommended to ensure it works when being called on its own before
using with \f[B]dehydrated\f[R] to issue real certificates and also to
ensure the \f[B]Luadns.com\f[R] credentials are correct etc.
At a minimum the \f[B]deploy_challenge\f[R] and
\f[B]clean_challenge\f[R] actions should be tested directly.
.PP
\f[B]dehydrated\f[R] itself will also follow the below procedure.
.PP
To use the script directly, 1st execute the following commands:
.PP
\f[B]$ export lua_email=\[lq]email\[at]example.com\[rq]\f[R]
.PD 0
.P
.PD
\f[B]$ export lua_api_key=\[lq]124\&...abc\&....uidlsj\[rq]\f[R]
.PP
Where \f[B]lua_email\f[R] and \f[B]lua_api_key\f[R] are the email login
and api created by the \f[B]Luadns.com\f[R] WebUI as mentioned above.
You can also source the \f[B]dehydrated\f[R] config directly, if the
required parameters have already been added.
.PP
\f[B]$ source /etc/dehydrated/config\f[R]
.PP
Then follow the below:
.PP
USAGE: \f[B]dehydrated-hook-luadns [ACTION] [ARGUMENTS]\f[R]
.SS ACTION
.PP
Supported are:
.IP "1." 3
\f[B]deploy_challenge\f[R]
.PD 0
.P
.PD
.IP "2." 3
\f[B]clean_challenge\f[R]
.PD 0
.P
.PD
.IP "3." 3
\f[B]deploy_cert\f[R]
.SS deploy_challenge
.PP
For \f[B]deploy_challenge\f[R] the following arguments are expected,
.PP
\f[B]$ dehydrated-hook-luadns deploy_challenge [FQDN] [TOKEN]
[TXT-TOKEN]\f[R]
.PP
\f[B]FQDN:\f[R] Fully Qualified Domain Name of Certificate being
requested.
\f[B]TOKEN:\f[R] This is actually for the HTTP-01 Challenge and is
unused.
\f[B]TXT-TOKEN:\f[R] Value of the TXT Record to be deployed
.PP
For multiple certificates with \f[B]HOOK_CHAIN=\[dq]yes\[dq]\f[R], these
arguments should be in a series like so:
.PP
\f[B]$ deploy_challenge fqdn1 token1 txt-token1 fqdn2 token2
txt-token2\f[R]
.SS clean_challenge
.PP
For \f[B]clean_challenge\f[R], the same arguments as
\f[B]deploy_challenge\f[R] are expected:
.PP
\f[B]$ dehydrated-hook-luadns clean_challenge [FQDN] [TOKEN]
[TXT-TOKEN]\f[R]
.PP
Likewise, for multiple certificates with
\f[B]HOOK_CHAIN=\[dq]yes\[dq]\f[R], these arguments should be in a
series like so:
.PP
\f[B]$ clean_challenge fqdn1 token1 txt-token1 fqdn2 token2
txt-token2\f[R]
.SS deploy_cert
.PP
If \f[B]deploy_cert\f[R] is used as an \f[B]ACTION\f[R], in this case
all input arguments are ignored.
.PP
\f[B]$ dehydrated-hook-luadns deploy_cert\f[R]
.PP
If one is using \f[B]nginx\f[R], this can be used to execute a reload of
nginx.
This requires the parameter in the dehydrated config
\f[B]automatic_nginx_reload=\[dq]yes\[dq]\f[R]
.PP
Set it to \f[B]\[dq]no\[dq]\f[R], comment it out, or omit it in the
dehydrated config to disable.
.SH DEHYDRATED OFFICAL HOOK SCRIPT DOCUMENTATION
.PP
See all supported hook script actions and their usage here:
.IP \[bu] 2
https://github.com/dehydrated-io/dehydrated/blob/master/docs/examples/hook.sh
.SH LUADNS.COM API KEY
.PP
An API key can be created via the Luadns.com WebUI relatively easily.
Log into the Luadns.com via your account and:
.IP "1." 3
In the \f[B]General\f[R] Tab - Select \f[B]Enable API Access\f[R]
.PD 0
.P
.PD
.IP "2." 3
In the \f[B]API Keys\f[R] Tab - Select \f[B]New API Key\f[R]
.PD 0
.P
.PD
.IP "3." 3
Select the \f[B]Zone\f[R] (Domain) you want it to have access to
.PD 0
.P
.PD
.IP "4." 3
Enter a Description, hit Save.
.PD 0
.P
.PD
.IP "5." 3
Download the API Key generated and save it to the \f[B]dehydrated\f[R]
config
.PD 0
.P
.PD
.IP "6." 3
Its a good idea to secure the config with a \f[B]chmod 700\f[R]
.PP
For security purposes one can only view the API key via the WebUI one
time so if it\[cq]s lost one will require creating a new API Key.
.PP
Note also that the default for Luadns.com is a single API key has access
to a single Zone (Domain).
Global API keys with access to all zones are not provided.
.SH DETAILED OPERATION
.PP
If one is interested, a detailed description of all the operations
carried out by the script are shown below for \f[B]deploy_challenge\f[R]
and \f[B]clean_challenge\f[R] actions.
.SS STEP 1 - INITIAL CHECK
.PP
An Initial check is carried out to see if a login email and api key are
correctly defined (or have been passed in by \f[B]dehydrated\f[R]).
The script will exit if either are undefined, as they are required to
interact with the LuaDNS REST API server.
.PP
Next, the dependencies are checked for.
This should be redundant if installed via the debian package, but is
included for good practise.
A check is carried out for \f[B]awk, curl, grep, jq, and sed\f[R].
If any are found not to be installed, the script will exit.
.SS STEP 2 - GET THE ZONE NAME
.PP
For a challenge \f[B]test1.test2.test3.example.org\f[R],
\f[B]dehydrated\f[R] will supply the script with exactly that as an
argument.
However the root domain, which in the above example is
\f[B]example.org\f[R] is required to interact with the Luadns API.
The script extracts this from what is passed in from
\f[B]dehydrated\f[R], and removes the trailing dot if present (this is
another requirement of the LuaDNS API).
.PP
If an invalid domain name is specified, the script will exit.
The check is relatively simple and is just based on the number of dots
present in what was passed in, so it is possible to confuse it.
However this is considered properly in the next step.
.SS STEP 3 - GET THE NS RECORDS FOR THE ZONE
.PP
Next, the script will query the main LuaDNS nameservers one after
another until valid NS (Nameserver) records are obtained.
The servers are:
.IP \[bu] 2
ns1.luadns.net
.PD 0
.P
.PD
.IP \[bu] 2
ns2.luadns.net
.PD 0
.P
.PD
.IP \[bu] 2
ns3.luadns.net
.PD 0
.P
.PD
.IP \[bu] 2
ns4.luadns.net
.PP
It would probably be possible to automatically assume that the NS
records will always point to the above, but it is possible to have
Vanity Nameservers with Luadns on their paid plans, which would mean
different NS records than the above.
These NS records are queried directly later to ensure that the record
has propagated correctly.
.PP
If no valid NS records are found from the above nameservers, the script
will exit.
This serves as a way of testing that the domain is valid and actually
using LuaDNS, before attempting to contact the API.
.SS STEP 4 - CARRY OUT THE ACTION
.SS deploy_challenge
.PP
For \f[B]deploy_challenge\f[R], at this point, the script has a valid
domain to work with, all dependencies and LuaDNS credentials.
It will then move on to do the following:
.IP \[bu] 2
Query the LuaDNS REST API for the Zone ID using the Zone Name from Step
2
.PD 0
.P
.PD
.IP \[bu] 2
Append \[lq]_acme-challenge.\[rq] to what was given by dehydrated to
create the record to deploy
.PD 0
.P
.PD
.IP \[bu] 2
Deploy the Record (Challenge)
.PD 0
.P
.PD
.IP \[bu] 2
Wait for Propagation to all Nameservers given by the NS Records from
Step 3
.PP
Curl is called to do this as per the documenation here:
.PD 0
.P
.PD
\f[B]https://www.luadns.com/api.html\f[R]
.PP
The script will check that a valid response is obtained for each of the
above operations by parsing the json data received, and will exit if a
problem is found.
.PP
After the record has found to be successfully deployed, the script will
then move on to query all the Nameservers found from the NS records of
\f[B]STEP 3\f[R] above for what was just deployed.
.PP
Each nameserver is queried for the record using \f[B]dig\f[R], and if
the record is not present, the script will wait a period and then try
again.
Each attempt the waiting time will double before trying again.
In the authors experience new records deployed via the API are very
quick to appear on \f[B]ALL\f[R] of the LuaDNS nameservers.
.PP
Once the record is found to be present on \f[B]ALL\f[R] of the
Nameservers given by the NS records of \f[B]STEP 3\f[R], the script will
move on to the next challenge to deploy or hand control back to
\f[B]dehydrated\f[R].
.SS clean_challenge
.PP
For \f[B]clean_challenge\f[R] the process is similiar:
.IP \[bu] 2
Append \[lq]_acme-challenge.\[rq] to what was given by dehydrated
.PD 0
.P
.PD
.IP \[bu] 2
Query the LuaDNS REST API for the Zone ID
.PD 0
.P
.PD
.IP \[bu] 2
Find the Record ID for a TXT record with the required name and content
.PD 0
.P
.PD
.IP \[bu] 2
Delete the Record (Challenge)
.PP
Curl is called to do this as per the documenation here:
.PD 0
.P
.PD
\f[B]https://www.luadns.com/api.html\f[R]
.PP
A check is done for the type (usually \f[B]TXT\f[R]), name and content
to find the record to delete.
All 3 need to be considered as for Wildcard certificates, two challenges
with the same name and different content are required to be deployed.
The response from the api server is tested that it is valid by parsing
the json data and investigating if the same Record ID was returned as
was given.
.PP
After that, the script will move on to the next challenge to clean or
hand control back to \f[B]dehydrated\f[R].
.PP
It is also possible at this point that there may be multiple records
with the same name, type, and content.
This is probably impossible to happen with \f[B]dehydrated\f[R] calling
the script, but may be possible if the script is called directly to do a
\f[B]deploy_challenge\f[R] without being followed by a
\f[B]clean_challenge\f[R] action, and doing the same
\f[B]deploy_challenge\f[R] action again.
.PP
If this happens, the script will cycle through each of the records found
with the same name, type and content and delete all of them.
.PP
This is an unusual edge case, and is probably very unlikely to happen
but is accounted for here.
.SH AUTHOR
.PP
Mark Finnan <mfinnan101@gmail.com>
.SH COPYRIGHT
.PP
Copyright (C) Mark Finnan 2025
.SH SEE-ALSO
.PP
dehydrated(1), curl(1), grep(1), dig(1), jq(1)
