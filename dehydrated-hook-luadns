#!/usr/bin/env bash
###############################
# DEHYDRATED HOOK SCRIPT FOR LUADNS.COM
###############################
# Github Page: https://github.com/zoot101/dehydrated-hook-luadns
###############################
#
# Script Dependencies are: awk, dig, grep, jq, curl
#

# Version Number
version="1.0.0"

###############################
# VARIABLES
###############################
lua_api_url="https://api.luadns.com/v1" 
prefix="_acme-challenge."
luadns_nameservers=( "ns1.luadns.net" "ns2.luadns.net" \
                     "ns3.luadns.net" "ns4.luadns.net" )

###############################
# FUNCTIONS
###############################
# Log functions
log1() {
  echo " + Hook:" "$@"
}

log2() {
  echo " + Hook: -->" "$@"
}

log3() {
  echo " + Hook: ---->" "$@"
}

# Function to check if a Variable is a number >= 0
is_number() {
  local number_regex='^[0-9]+$'
  if ! [[ "$1" =~ $number_regex ]]; then
    return 1
  else
    return 0
  fi
}

# Query an Auth Nameserver for the Zone NS Records using dig
query_zone_ns_records() {
  local auth_nameserver="${1}"
  local fqdn="${2}"
  dig +short +retry=3 @"${auth_nameserver}" NS "${fqdn}"
}

# Query Auth Nameserver for TXT Record Deployed using dig
query_nameserver() {
  local auth_server="${1}"
  local name="${2}"
  local content="${3}"
  dig +short +retry=3 @"${auth_server}" TXT "${name}" | grep -qw "${content}"
}

# Base Curl Command as per the Luadns.com REST API documentation
curl_cmd() {
  curl --retry 3 --silent --show-error -u "${lua_email}:${lua_api_key}" \
  -H 'Accept: application/json' "$@"
}

# Check that the lua_email and lua_api_token variables have been defined
luadns_credentials_check(){
  if [ -z "${lua_email}" ]; then
    log1 "ERROR: Luadns Email (lua_email) empty - Exiting"
    exit 1
  elif [ -z "${lua_api_key}" ]; then
    log1 "ERROR: Luadns API Key (lua_api_key) empty - Exiting"
    exit 1
  fi
}

# Check dependencies are installed
check_dependencies() {
  if [ -z $(which curl) ]; then
    log1 "ERROR: curl is not installed - Exiting"
    exit 1
  elif [ -z $(which dig) ]; then
    log1 "ERROR: dig is not installed - Exiting"
    exit 1
  elif [ -z $(which grep) ]; then
    log1 "ERROR: grep is not installed - Exiting"
    exit 1
  elif [ -z $(which awk) ]; then
    log1 "ERROR: awk is not installed - Exiting"
    exit 1
  elif [ -z $(which sed) ]; then
    log1 "ERROR: sed is not installed - Exiting"
    exit 1
  elif [ -z $(which jq) ]; then
    log1 "ERROR: jq is not installed - Exiting"
    exit 1
  fi 
}

# Check if the Record passed from dehydrated is a CNAME. If so use that instead.
# This allows for the case where the user wants to use a different domain for certificate
# validation and issue.
check_for_cname() {
  local fqdn="${1}"
  if [ -n "${fqdn}" ]; then cname_check=$(dig +short CNAME "${fqdn}"); fi
  if [ -n "${cname_check}" ]; then
    log1 "CNAME Found: ${cname_check} - Proceeding with that instead"
    record_name="${cname_check}"
  fi
}

# Break the fqdn apart to isolate the zone name (example.tld)
get_zone_name_from_fqdn() {
  local fqdn="${1}"

  # Exit if the fqdn is empty or does not have at least 1 dot.
  if [ -z "${fqdn}" ] || [ -z $( echo "${fqdn}" | awk -F "." '{print $2}') ]; then
    log1 "ERROR (Invalid fqdn supplied)"
    exit 1
  fi
 
  # Remove trailing dot - required to present for Record ID, but not Zone ID
  if [ "${fqdn:0-1}" == "." ]; then 
    fqdn="${fqdn::i-1}"
  fi
 
  # Pick Everything after the 2nd last "." to get the root-domain
  zone_name=$( echo "${fqdn}" | awk -F "." '{ printf $(NF-1)"."$NF}')
}

# Get NS Records for Zone (Root of the domain passed in)
get_zone_nameservers() { 

  # Zone Name
  local zone="${1}"

  # Number of starting nameservers
  local N_luadns_nameservers=${#luadns_nameservers[@]}
  log1 "Querying Luadns Nameservers for" "${zone}" "NS Records..."

  # Query each of the nameservers defined above for NS Records
  for i in $(seq 0 1 $((N_luadns_nameservers-1))); do
    log2 "Querying Nameserver" $((i+1))"/"$N_luadns_nameservers":" "${luadns_nameservers[$i]}"

    # Call above function to use dig to get NS records
    if ! zone_ns_records=$(query_zone_ns_records "${luadns_nameservers[$i]}" "${zone}"); then
      log3 "No NS records obtained from" "${luadns_nameservers[$i]}" "- Trying Next Nameserver..."

    else
      # Got a Valid Reply - Get number of nameservers obtained
      N_zone_ns_records=$( echo "${zone_ns_records}" | wc -l)
      log3 "Success: Obtained" $N_zone_ns_records "NS records for" "${zone}"
      break
    fi

    # Otherwise check if all initial nameservers have been tried
    if [ $i == $((N_luadns_nameservers-1)) ]; then
      log3 "ERROR: Could not find NS records for" "${zone}" "from any Luadns Nameserver"
      log3 "       Is the domain correct and using Luadns Nameservers?"
      exit 1
    fi
  done
}

###############################
# LUADNS API FUNCTIONS
###############################
# Official Documentation is https://www.luadns.com/api.html

check_response_was_valid() {
  # Easiest thing to do is check the length of the string obtained
  local response="${1}"
  if [ ${#response} -lt 100 ]; then
    log2 "ERROR: Invalid Response received from server - Exiting."
    exit 1
  fi 
}

# Get the Zone ID for the above Domain Name
luadns_get_zone_id() {
  local luadns_zone_name="${1}"

  # Sanity Check that the zone_name given is not empty.
  if [ -z "${luadns_zone_name}" ]; then
    log2 "ERROR: Zone Name is empty"
    exit 1
  fi

  # Get the Zone ID for the Domain Above using the API
  local response=$( curl_cmd "${lua_api_url}"/zones ) 
  check_response_was_valid "${response}"

  # Parse Response with jq command to pick out the Zone ID & Check if it's a number
  zone_id=$(echo "${response}" | jq ".[] | select(.name==\"${luadns_zone_name}\").id") 
  if ! is_number "${zone_id}"; then
    log2 "ERROR: Zone ID could not be obtained - Problem with API Key?"
    exit 1
  fi
}

# Create a new record using the Luadns.com API
luadns_create_new_record() {
  local luadns_zone_id="${1}"
  local luadns_record="${2}"
  local luadns_record_type="${3}"
  local luadns_record_content="${4}"

  # Add trailing dot if not present - required for the Record ID
  if [ "${luadns_record:0-1}" != "." ]; then
    luadns_record="${luadns_record}""."
  fi

  # Create New Record as per official API Documentation & Check Response
  local response=$(curl_cmd -X POST \
    -d "{ \":zone_id\":${luadns_zone_id}, \"name\":\"${luadns_record}\", \"type\":\"${luadns_record_type}\", \"content\":\"${luadns_record_content}\"}" \
    "${lua_api_url}"/zones/$zone_id/records)
  check_response_was_valid "${response}"

  # Check the record content deployed was received back
  local success_check=$(echo "${response}" | jq ".content")
  if [ "${success_check}" == \""${luadns_record_content}"\" ]; then
    log2 "Record successfully deployed."
  else
    log2 "ERROR: Problem deploying record"
    exit 1
  fi
}

# Get the Record ID for a given record using the Luadns.com API
luadns_get_record_id() {
  local luadns_zone_id="${1}"
  local luadns_record_name="${2}"
  local luadns_record_content="${3}"

  # Add trailing dot if not present - required for the Record ID
  if [ "${luadns_record_name:0-1}" != "." ]; then
    luadns_record_name="${luadns_record_name}""."
  fi

  # Get the record id for the above record using the API & Check Response
  local response=$(curl_cmd "${lua_api_url}"/zones/${luadns_zone_id}/records)
  check_response_was_valid "${response}"

  # Process the json data received to select TXT Type, Name and Content & Check Response
  # (Can't use number check here as in certain edge cases multiple IDs are received...)
  record_id=$(echo "${response}" | jq ".[] | select(.name==\"${luadns_record_name}\" and .type==\"TXT\" and .content==\"${luadns_record_content}\").id")
  if [ -z "${record_id}" ]; then
    log2 "ERROR: Record ID could not be obtained - Does the record exist?"
    exit 1
  fi
}

# Delete a record using the LuaDNS API
luadns_delete_record() {
  local luadns_zone_id="${1}"
  local luadns_record_id="${2}"
  local k=0

  # Do a check for multiple record IDs and loop through them if found
  local N_luadns_record_id=$( echo "${luadns_record_id}" | wc -l)
  if [ $N_luadns_record_id != 1 ]; then
    log2 "Found" $N_luadns_record_id "Record IDs?? - Will delete all of them"
  fi

  # Loop through all record IDs
  for k in $(seq 1 1 $N_luadns_record_id); do
    local luadns_record_id_2=$(echo "${luadns_record_id}" | sed -n "$k"p)

    # Use the zone_id and the record_id to delete the record & Check Response
    local response=$(curl_cmd -X DELETE "${lua_api_url}"/zones/${luadns_zone_id}/records/${luadns_record_id_2})
    check_response_was_valid "${response}"
  
    # Check for success - Was the same record id returned after the deletion?
    local success_check=$(echo "${response}" | jq ".id")
    if [ "${success_check}" == "${luadns_record_id_2}" ]; then
      log2 "Record:" "${luadns_record_id_2}" "Successfully Deleted"
    else
      log2 "ERROR: Problem Deleting Record" "${luadns_record_id_2}"
      exit 1
    fi
  done
}

# Wait for the record to be live on all of the Nameservers obtained earlier
wait_for_record_to_propagate() {
  local delay_time=2
  local retries=11
  local luadns_record_name="${1}" 
  local luadns_record_content="${2}"
  local i=1
  local j=1
  log1 "Querying all" $N_zone_ns_records "${zone_name}" "Nameservers for Record..."

  # Loop through each of the Zone NS Records to Query each of them
  for j in $(seq 1 1 $N_zone_ns_records); do
    local nameserver=$(echo "${zone_ns_records}" | sed -n "$j"p)
    log2 "Nameserver" $j"/"$N_zone_ns_records":" "${nameserver}" 
  
    # Try up to a maximum of $retries..
    for i in $(seq 1 1 $retries); do
  
      # Wait delay_time^i seconds so the wait time doubles each try...
      wait_time=$(($delay_time**$i))
      log3 "Waiting" $wait_time "seconds"
      sleep $wait_time
    
      # Check to see if the record has been deployed or not
      log3 "Querying for record - Try:" $i"/"$retries
      if query_nameserver "${nameserver}" "${luadns_record_name}" "${luadns_record_content}"; then
        log3 "Record live"
        break
      elif [ $i == $retries ]; then
        log3 "ERROR: Record not live after" $retries "tries - Exiting"
        exit 1
      else
        log3 "Record not yet live - Retrying..."
        i=$((i+1))
      fi
    done 
  done

  # Print Success
  log2 "Record successfully deployed and live"
}

# Check number of arguments are divisble by 3 - Required for HOOK_CHAIN
check_div_by_3() {
  local args_number1=$#
  local args_number_check=$(( args_number1 % 3))
  if [ $args_number_check != 0 ]; then
    log1 "ERROR: Invalid number of arguments specified - It should be a"
    log1 "       multiple of 3 - Exiting"
    exit 1
  fi
}

###############################
# MAIN SCRIPT FUNCTIONS
###############################

# Deploy Single Challenge Function - $1 = Domain, $2 = TXT Record Value
deploy_single_challenge() {
  local domain="${1}" token_filename="${2}" token_value="${3}"

  # Append the "_acme-challenge." to the domain
  local record_name="${prefix}"$domain
  log1 "Name:${record_name}, Type:TXT, Value:${token_value}"
 
  # Check if the Record is a CNAME, if so use what the CNAME points to instead
  check_for_cname "${record_name}"

  # Extract the Root Domain to allow getting the Zone ID
  get_zone_name_from_fqdn "${record_name}"
  log1 "Zone Name:" "${zone_name}"

  # Now Query the Luadns nameservers for the actual NS records
  get_zone_nameservers "${zone_name}"
  log1 "Deploying record via" "${lua_api_url}""..."

  # Get Zone ID From LuaDNS API...
  log2 "Getting Zone ID..."
  luadns_get_zone_id ${zone_name}
  log2 "Zone ID:" $zone_id

  # Create Record using LuaDNS API (Type TXT) & Wait for Publication
  luadns_create_new_record "${zone_id}" "${record_name}" "TXT" "${token_value}"
  wait_for_record_to_propagate "${record_name}" "${token_value}"
}

# Clean Single Challenge Function - $1 = Domain, $2 = TXT Record Value
clean_single_challenge() {
  local domain="${1}" token_filename="${2}" token_value="${3}"

  # Append the "_acme-challenge." to the domain 
  local record_name="${prefix}"$domain
  log1 "Name:${record_name}, Type:TXT, Value:${token_value}"  

  # Check if the Record is a CNAME, if so use what the CNAME points to instead
  check_for_cname "${record_name}"

  # Extract the Root Domain to allow getting the Zone ID
  get_zone_name_from_fqdn "${record_name}"
  log1 "Zone Name:" "${zone_name}"
  log1 "Deleting record via" "${lua_api_url}""..."

  # Get the Zone ID From LuaDNS API...
  log2 "Getting Zone ID..."
  luadns_get_zone_id ${zone_name}
  log2 "Zone ID:" $zone_id

  # Now use the zone id to get the record id
  log2 "Getting Record ID..."
  luadns_get_record_id ${zone_id} ${record_name} "${token_value}"

  # Print the 1st Record ID found and delete the record
  log2 "Record ID:" $(echo "${record_id}" | sed -n 1p)
  luadns_delete_record "${zone_id}" "${record_id}" 
}

# Main Deploy Challenge Function
deploy_challenge() {

  # Check depedencies and Credentials
  check_dependencies
  luadns_credentials_check

  # Compute Number of Arguments Passed In - Check if divisible by 3
  local args_number=$#
  check_div_by_3 "$@"
  local challenges_number=$(( args_number / 3 ))

  # Print Greeting Banner
  log1 "############################"
  log1 "# Dehydrated-Hook-Luadns Version: ${version}"

  # Loop Through the Input Parameters in groups of 3
  index_d=1
  while (( ${#} )); do
    log1 "############################"
    log1 "+ deploy_challenge:" $index_d "of" $challenges_number
    log1 "############################"
    deploy_single_challenge "${1}" "${2}" "${3}"
    shift 3
    index_d=$((index_d+1))
  done
  log1 "############################"
  log1 "+ SUCCESS: All Challenges successfully deployed and now live"
  log1 "############################"
  exit 0
}

# Main Clean Challenge Function
clean_challenge() {

  # Check dependencies and Credentials
  check_dependencies
  luadns_credentials_check

  # Compute Number of Arguments Passed In - Check if divisible by 3
  local args_number=$#
  check_div_by_3 "$@"
  local challenges_number=$(( args_number / 3 ))

  # Print Greeting Banner
  log1 "############################"
  log1 "# Dehydrated-Hook-Luadns Version: ${version}"

  # Now Loop Through the Input Parameters in groups of 3
  index_c=1
  while (( ${#} )); do
    log1 "############################"
    log1 "+ clean_challenge:" $index_c "of" $challenges_number
    log1 "############################"
    clean_single_challenge "${1}" "${2}" "${3}"
    shift 3
    index_c=$((index_c+1))
  done
  log1 "############################"
  log1 "+ SUCCESS: All Challenges cleaned"
  log1 "############################"
  exit 0
}

# Main Deploy Cert Function
deploy_cert() {

  # Reload nginx if the following is included in the dehydrated config
  if [ ! -z "${automatic_nginx_reload}" ]
  then
    if [ "${automatic_nginx_reload}" == "yes" ]; then
      log1 "Reloading nginx..."
      # Reload nginx via systemctl but prevent the script throwing an error
      systemctl reload nginx || log2 "Problem reloading nginx..."
      exit 0
    fi
  fi
}

###############################
# SCRIPT START
###############################
# Valid Arguments for the Script are "deploy_challenge", "clean_challenge" and
# "deploy_cert" only. Exit cleanly for all other unrecognised arguments
HANDLER="$1"; shift
if [[ "${HANDLER}" =~ ^(deploy_challenge|clean_challenge|deploy_cert)$ ]]; then
  "$HANDLER" "$@"
else
  exit 0
fi
